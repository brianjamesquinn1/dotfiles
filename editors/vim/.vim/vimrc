" Runtime Paths "
set rtp+=/usr/local/opt/fzf "path for fzf

" Filetype "
set nocompatible
filetype off
filetype plugin indent on

" File Explorer "
let g:netrw_list_hide= '.*\.swp$,\.orig$'

" Syntax "
syntax on
let g:python_highlight_all = 1

" Characters "
set backspace=indent,eol,start

" Spacing "
set autoindent
set expandtab
set shiftwidth=2
set tabstop=2

" Mouse "
set mouse=a

" Visual "
set background=dark
set laststatus=2
set noequalalways
set noshowmode
set nowrap
set number
set ruler

" Gruvbox Colors "
let g:gruvbox_inverse = 0

" Randomize Colorscheme "
let colorschemes = ['everforest', 'gruvbit', 'gruvbox', 'gruvbox-material', 'monokai', 'monokai_pro', 'sonokai']
execute 'colorscheme' colorschemes[rand() % (len(colorschemes) - 1 ) ]
let $BAT_THEME = g:colors_name

" Generic Colors "
highlight RipgrepBlue cterm=none ctermfg=14   ctermbg=none
highlight DiffAdd     cterm=none ctermfg=118  ctermbg=none
highlight DiffDelete  cterm=none ctermfg=52   ctermbg=52
highlight DiffChange  cterm=none ctermfg=none ctermbg=none
highlight DiffText    cterm=none ctermfg=220  ctermbg=240
highlight Search      cterm=none ctermfg=14   ctermbg=none

" Persist After ColorScheme Change
autocmd ColorScheme * highlight RipgrepBlue cterm=none ctermfg=14   ctermbg=none
autocmd ColorScheme * highlight DiffAdd     cterm=none ctermfg=118  ctermbg=none
autocmd ColorScheme * highlight DiffDelete  cterm=none ctermfg=52   ctermbg=52
autocmd ColorScheme * highlight DiffChange  cterm=none ctermfg=none ctermbg=none
autocmd ColorScheme * highlight DiffText    cterm=none ctermfg=220  ctermbg=240
autocmd ColorScheme * highlight Search      cterm=none ctermfg=14   ctermbg=none

" Plugin Settings "
" ALE
" TODO figure out how to only lint on save
let g:ale_detail_to_floating_preview=1
let g:ale_echo_msg_format = '%s'
let g:ale_elixir_elixir_ls_release = $WORKSPACE.'/elixir-ls/release'
let g:ale_fix_on_save = 1
let g:ale_lint_delay = 0
let g:ale_lint_diff = 1
let g:ale_lint_on_enter = 0
let g:ale_lint_on_enter = 0
let g:ale_lint_on_filetype_changed = 0
let g:ale_lint_on_insert_leave = 0
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_sign_error = '>>'
let g:ale_sign_info = ' ?'
let g:ale_sign_style_error = '>>'
let g:ale_sign_style_warning = '--'
let g:ale_sign_warning = '--'
let g:ale_virtualtext_cursor = 'disable'
let g:ale_linters = {
      \  'cpp': [
      \    'clang',
      \    'clangcheck',
      \    'clangd',
      \    'flawfinder',
      \  ],
      \  'elixir': [
      \    'credo',
      \    'elixir-ls',
      \  ],
      \  'go': [
      \    'golint',
      \    'gopls',
      \  ],
      \  'javascript': [
      \    'eslint',
      \    'flow-language-server',
      \  ],
      \  'typescript': [
      \    'prettier',
      \    'eslint',
      \  ],
      \  'python': [
      \    'pyright',
      \  ],
      \  'rust': [
      \    'rustc',
      \    'rls',
      \  ],
      \  'vim': [
      \    'vimls',
      \  ],
      \ }
let g:ale_fixers = {
      \  'cpp': [
      \    'clang-format',
      \    'clangtidy',
      \  ],
      \  'elixir': [
      \    'mix_format',
      \  ],
      \  'go': [
      \    'gofmt',
      \    'goimports',
      \  ],
      \  'javascript': [
      \    'prettier',
      \    'eslint',
      \  ],
      \  'typescript': [
      \    'prettier',
      \    'eslint',
      \  ],
      \  'rust': [
      \    'rustfmt',
      \  ],
      \ }

" Fugitive
" Autoupdate git window
autocmd BufWritePost,BufDelete * if bufexists('fugitive://') | execute 'Git' | endif

" Fzf/Ripgrep
let g:fzf_vim = {}
let g:fzf_vim.files_options = '--color hl:14,hl+:214'
let g:fzf_vim.rg_options = '--delimiter : --nth 4.. --color hl:14,hl+:214'

" Lightline "
let g:lightline = {
      \  'colorscheme': 'wombat',
      \ }
let g:lightline.component_expand = {
      \  'gitdiff': 'lightline#gitdiff#get',
      \  'linter_checking': 'lightline#ale#checking',
      \  'linter_infos': 'lightline#ale#infos',
      \  'linter_warnings': 'lightline#ale#warnings',
      \  'linter_errors': 'lightline#ale#errors',
      \  'linter_ok': 'lightline#ale#ok',
      \ }
let g:lightline.component_function = {
      \  'gitbranch': 'FugitiveHead' }
let g:lightline.component_type = {
      \  'linter_checking': 'right',
      \  'linter_infos': 'right',
      \  'linter_warnings': 'warning',
      \  'linter_errors': 'error',
      \  'linter_ok': 'right',
      \ }
let g:lightline.active = {
      \ 'left': [ [ 'mode', 'paste' ],
      \           [ 'gitbranch' ],
      \           [ 'gitdiff', 'filename', 'readonly', 'modified' ] ],
      \ 'right': [ [ 'linter_errors', 'linter_warnings', 'linter_ok' ],
      \            [ 'lineinfo' ],
      \            [ 'percent' ] ] }
let g:lightline#ale#indicator_errors = "\u2716"
let g:lightline#ale#indicator_ok = "\u2713"
let g:lightline#ale#indicator_warnings = "\u23f5"
let g:lightline#gitdiff#indicator_added = "+"
let g:lightline#gitdiff#indicator_deleted = "-"
let g:lightline#gitdiff#indicator_modified = "\u26cf"

" Lsp (vim-lsp)
" TODO figure out how to only lint on save
autocmd User lsp_float_opened
      \ call popup_setoptions(lsp#ui#vim#output#getpreviewwinid(), {
      \  'borderchars': ['─','│','─','│','┌','┐','┘','└'],
      \ })
let g:asyncomplete_auto_popup = 0
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_diagnostics_echo_delay = 0
let g:lsp_diagnostics_float_cursor = 1
let g:lsp_diagnostics_float_delay = 100
let g:lsp_diagnostics_signs_delay = 0
let g:lsp_diagnostics_signs_error = {'text': '>>'}
let g:lsp_diagnostics_signs_warning = {'text': '--'}
let g:lsp_document_code_action_signs_delay = 0
let g:lsp_document_code_action_signs_enabled = 0
let g:lsp_signature_help_enabled = 0

" Quickfix Reflector 
let g:qf_modifiable = 0

" Functions "
" Toggles blame window
function! Blame_Toggle()
  let found = 0
  for winnr in range(1, winnr('$'))
    if getbufvar(winbufnr(winnr), '&filetype') ==# 'fugitiveblame'
      exe winnr . 'close'
      let found = 1
    endif
  endfor
  if !found
    Git blame --date=format:"%Y-%b"
  endif
endfunction

" Close corresponding diff window
function! Close_Corresponding()
  for w in range(1, winnr('$'))
    let b = winbufnr(w)
    if b != -1 && bufname(b) =~# '^fugitive://'
      execute w . 'wincmd c'
    endif
  endfor
endfunction

" Safely closes a diff buffer
function! Close_Diff()
  if (!&diff && !getbufvar('#', '&diff')) || (bufname('%') !~ '^fugitive:' && bufname('#') !~ '^fugitive:')
    echom "Not in diff view."
    return
  endif

  " Close current buffer if alternate is not fugitive but current one is.
  if bufname('%') =~ '^fugitive:' && bufname('#') !~ '^fugitive:' 
    if bufwinnr("#") == -1
      b #
      bd #
    else
      bd
    endif
  else
    bd #
  endif
endfunction

" Toggles a diff buffer
function! Diff_Toggle()
    if &diff
        call Close_Diff()
    else
        Gdiff
        wincmd p
    endif
endfunction

" Toggles a difflist in the quickfix list
function! Difflist_Toggle()
  " Check if a quickfix window is open
  if empty(filter(getwininfo(), 'v:val.quickfix'))
    " Quickfix not open: run fugitive Git difftool to populate and open it
    Git difftool --name-only
    copen
  else
    " Quickfix is open: close it
    cclose
  endif
endfunction

" Toggles the fugitive git window
function! Git_Toggle() abort
  for l:winnr in range(1, winnr('$'))
    if !empty(getwinvar(l:winnr, 'fugitive_status'))
      exe l:winnr 'close'
      return
    endif
  endfor
  belowright keepalt Git
  resize 10
  setlocal winfixheight
endfunction

function! Quickfix_Toggle()
  if empty(filter(getwininfo(), 'v:val.quickfix'))
    copen
  else
    cclose
  endif
endfunction

" Scrolls up without changing the position of the cursor
function! Scroll_Up()
    let row = winline()            " cursor's screen row
    if line('.') > 1               " avoid top-of-file errors
        execute "normal! k"
        call winrestview({'topline': line('.') - row + 1})
    endif
endfunction

" Scrolls down without changing the position of the cursor
function! Scroll_Down()
    let row = winline()            " cursor's screen row
    if line('.') < line('$')       " avoid bottom-of-file errors
        execute "normal! j"
        call winrestview({'topline': line('.') - row + 1})
    endif
endfunction


nnoremap <C-Up> :call ScrollWindowUp()<CR>
nnoremap <C-Down> :call ScrollWindowDown()<CR>

" Commands "
command! -bang -nargs=0 BlameToggle call Blame_Toggle()
command! -bang -nargs=0 CloseCorresponding call Close_Corresponding()
command! -bang -nargs=0 DiffToggle call Diff_Toggle()
command! -bang -nargs=0 DifflistToggle call Difflist_Toggle()
command! -bang -nargs=0 GitToggle call Git_Toggle()
command! -bang -nargs=0 QuickfixToggle call Quickfix_Toggle()
command! -bang -nargs=0 ScrollUp call Scroll_Up()
command! -bang -nargs=0 ScrollDown call Scroll_Down()
command! -bang -nargs=0 LspRestart call lsp#disable() | call lsp#enable()
command! HelpTags packloadall | silent! helptags ALL

" Mappings "

" Originally mapped to group similar functionality (ie all LSP functions
" interact with CTRL), but have now changed so the mappings group similar
" interaction patterns (ie does it open new buffers? floating window? etc)

" General Pattern
" ]/[ mappings navigate in search
" <leader> mappings do in buffer operations
" <Space> mappings open new buffers/fullscreen floating windows
" <C-*> (ctrl) mappings jump buffers, do under cursor operations,
" and replace <leader>/<Space> in insert mode operations

" Quit tab
cnoreabbrev <expr> qt (getcmdtype() == ':' ? 'tabclose' : 'qt')
" Write quit tab
cnoreabbrev <expr> wqt (getcmdtype() == ':' ? 'w \| tabclose' : 'wqt')
" Tab split
cnoreabbrev <expr> tsp (getcmdtype() == ':' ? 'tab split' : 'tsp')
" Tab explorer
cnoreabbrev <expr> tex (getcmdtype() == ':' ? 'tabedit %:p:h' : 'tex')
" Open all diff files in split view from provided branch/commit (use for code review)
cnoreabbrev <expr> PR (getcmdtype() == ':' && getcmdline() ==# 'PR' ? 'Git difftool -y' : 'PR')
" Lists all changed files in quickfix list
cnoreabbrev <expr> difflist (getcmdtype() == ':' && getcmdline() ==# 'difflist' ? 'Git difftool --name-only' : 'difflist')
" Opens all conflicted files in a 3 pane split
cnoreabbrev <expr> Merge (getcmdtype() == ':' && getcmdline() ==# 'Merge' ? 'Git mergetool -y' : 'Merge')
" Pull local (left) changes into merge file
cnoreabbrev <expr> DGL (getcmdtype() == ':' && getcmdline() ==# 'DGL' ? 'diffget //2**/<C-r>%' : 'DGL')
" Pull remote (right) changes into merge file
cnoreabbrev <expr> DGR (getcmdtype() == ':' && getcmdline() ==# 'DGR' ? 'diffget //3**/<C-r>%' : 'DGR')
" Map common mistype for symbol renaming
cnoreabbrev <expr> LspReplace (getcmdtype() == ':' && getcmdline() ==# 'LspReplace' ? 'LspRename' : 'LspReplace')

" Enter - select from popup menu
inoremap <expr> <CR> pumvisible() ? "\<C-Y>" : "\<CR>"

" / - Highlight
" Set highlight on buffer search
nnoremap <silent> <leader>/ :set hlsearch!<CR>

" A - Alerts
" Toggle gutter diagnostics
nnoremap <silent> <leader>d :ALEToggle<CR>
inoremap <silent> <C-d> <C-\><C-O>:ALEToggle<CR>

" B - Blame
" Toggles a blame buffer
nnoremap <silent> <leader>b :BlameToggle<CR>
nnoremap <silent> <Space>b :BlameToggle<CR>

" C - Changes
" Toggles diff (changes) buffer
nnoremap <silent> <leader>c :DiffToggle<CR>
" Opens a changelist in quickfix list
nnoremap <silent> <Space>c :DifflistToggle<CR>
" Opens all modified files in diffview in separate tabs
nnoremap <silent> <Space>C :Git difftool -y<CR>

" D - Diff/Definition
" Pop up definition
nnoremap <silent> <leader>d :LspPeekDefinition<CR>
" Open diff buffer
nnoremap <silent> <Space>d :LspDefinition<CR>
" Jump to definition
nnoremap <silent> <C-d> :LspDefinition<CR>

" E - Error
" Jump to next error/warning
nnoremap <silent>]e :ALENextWrap<CR>
" Jump to previous error/warning
nnoremap <silent>[e :ALEPreviousWrap<CR>
" Pop up full error
nnoremap <silent> <leader>e :ALEDetail<CR>
" Open quickfix with diagnostics (errors) listed
nnoremap <silent> <Space>e :ALEPopulateQuickfix<CR>:copen<CR>

" F - Find
" Search for word under cursor in file
nnoremap <silent> <leader>f /<C-r><C-w><CR>N :set hlsearch<CR>
" Open ripgrep search
nnoremap <silent> <Space>f :Rg<CR>
" Ripgrep word under cursor
nnoremap <silent> <C-f> :Rg <C-r><C-w><CR>

" G - Git
" Toggle gutter diff
nnoremap <silent> <leader>g :GitGutterToggle<CR>
inoremap <silent> <C-g> <C-\><C-O>:GitGutterToggle<CR>
" Toggle fugitive git status window
nnoremap <silent> <Space>g :GitToggle<CR>

" H - Hover details
" Pop up LSP hover information
nnoremap <silent> <leader>h :LspHover<CR>

" I - Implementation
" Pop up implementation
nnoremap <silent> <leader>i :LspPeekImplementation<CR>
" Jump to implementation
nnoremap <silent> <Space>i :LspImplementation<CR>
nnoremap <silent> <C-i> :LspImplementation<CR>

" N - Next/Name
" Next item in quickfix list
nnoremap <silent>]n :CloseCorresponding<CR>:cn<CR>
" Previous item in quickfix list
nnoremap <silent>[n :CloseCorresponding<CR>:cp<CR>
" Symbol (re)name (lsp identified occurences)
nnoremap <silent> <leader>n /<C-r><C-w><CR>N :LspRename<CR>
nnoremap <silent> <C-n> :LspRename<CR>

" P - Project
" Open file search
nnoremap <silent> <Space>p :GFiles<CR>

" Q - Quickfix
" Toggle quickfix window
nnoremap <silent> <leader>q :QuickfixToggle<CR>
nnoremap <silent> <Space>q :QuickfixToggle<CR>

" R - References/Restart
" Restart the LSP server
nnoremap <silent> <leader>r :LspRestart<CR>
" Open references
nnoremap <silent> <Space>r :LspReferences<CR>
nnoremap <silent> <C-r> :LspReferences<CR>

" U - Update/Undo
" Reload (update) buffer with any changes
nnoremap <silent> <leader>u :e<CR>
nnoremap <silent> <Space>u :e<CR>
" FORCE reload (update) buffer with any changes
nnoremap <silent> <C-u> :e!<CR>
" Redo mapping basic capital U to redo since ctrl-r is remapped
nnoremap <silent> U :redo<CR>

" W - Window
nnoremap <leader>w :execute "resize " . input("Height: ")<CR>

" Arrow Keys - Movement/Buffer Sizes
nnoremap <leader><UP> :resize +5<CR>
nnoremap <leader><DOWN> :resize -5<CR>
nnoremap <leader><LEFT> :vertical resize -5<CR>
nnoremap <leader><RIGHT> :vertical resize +5<CR>
nnoremap <C-Up> :ScrollUp<CR>
nnoremap <C-Down> :ScrollDown<CR>


" Space - Completion (ie 'blank')
" Trigger autocompletion
imap <C-@> <plug>(asyncomplete_force_refresh)
